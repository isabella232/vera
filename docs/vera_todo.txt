### TODO
Cluster reconfigurations.
   - Peer configuration stored and fetchable from log
      - leveldb log
   - Non-voting members (read only raft instances)
   - Server must use latest configuration, regardless of whether the log entry
     has been committed or not.
   - Leader step down as part of cluster reconfiguration if it isn't part of
     Cnew.
   - Where does it make sense in tests to make sure the cluster config is
     correct and where to just leave the default empty object?
Leader regularly commits suicide as a chaos-monkey type thing.
Add Flease to cliffsnotes.
"run random" and see what it does.
cli to issue commands to an in-mem cluster (same framework as a plaintext test
   framework?)
command log truncation.
request id logging through pipelines (should only be done in the server, no?)
revamp error handling in raft class
Log (cumulative?) checksums
Separate out Raft deviations document.
All raft.js#TODOs
Raft action log that can turn into sequence diagram.
Tools:
  - add/remove/promote a new peer
  - force leader to step down

### Tests for reconfiguration
- Successful, no problems
- Old dies after starting to use old/new, before committing
- Old dies right after new config is propagated to majority
- Old leader isn't in new configuration
- New leader finishes up the reconfiguration
- Multiple cluster reconfigurations at the same time

### Overall todo:
* Solidly tested Raft Core
* API design and one api stubbed
* Other APIs
* Client

### Examples of plaintext tests:
cluster of 3
set 0.leaderTimeout to 0
tick until 0.state is leader
tick 20
check 0.state is leader

cluster of 1
tick until 0.state is leader

cluster of 3
set 0.leaderTimeout to 0
tick until 0.state is leader
client foo bar baz
tick until stateMachine.data is baz

### Working out request flow for cluster reconfigurations
Client request to add a peer
Leader creates Cold,new, sends it through append entries, returns.
AppendEntries looks at stream as it goes by, sees new configuration, starts
  using it, commits entry like normally does.
Leader sees Cold,new committed, kicks off Cnew append entries, returns.
AppendEntries looks at stream as it goes by, sees new configuration, starts
  using it, commits entry like normally does

### Random questions
How do elections work with Cold,new?
How does an operator recover from something weird happening after the client
   request is sent off?

### Message Bus interface.

var messageId = self.messageBus.send(self.id, peer, message, onResponse);
self.messageBus.cancel(messageId);
