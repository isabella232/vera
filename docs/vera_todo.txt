### TODO
Cluster reconfigurations.
   - Sending snaphots to new peers.
   - Peers that aren't part of new config... what do they do?
   - Non-voting members should never transistion to candidate.
   - Autopromotion at the "right time" (after it has finished botstrapping from
     a peer).
   - Testing, testing, testing.
   - Emit events when cluster config has changed?
Read-only peers hanging off a non-leader (?)
Add Flease to cliffsnotes.
"run random" and see what it does.
cli to issue commands to an in-mem cluster (same framework as a plaintext test
   framework?)
command log truncation.
request id logging through pipelines (should only be done in the server, no?)
revamp error handling in raft class
Log (cumulative?) checksums
Separate out Raft deviations document.
All raft.js#TODOs
Raft action log that can turn into sequence diagram.
Tools:
  - add/remove/promote a new peer
  - force leader to step down
Leader regularly commits suicide as a chaos-monkey type thing.

### Tests for reconfiguration
- Successful, no problems
- Old dies after starting to use old/new, before committing
- Old dies right after new config is propagated to majority
- Old leader isn't in new configuration
- New leader finishes up the reconfiguration
- Multiple cluster reconfigurations at the same time
- What a raft instance does when it isn't in the new config
- Read only instances shouldn't try to get votes

### Overall todo:
* Solidly tested Raft Core
* API design and one api stubbed
* Other APIs
* Client

### Examples of plaintext tests:
cluster of 3
set 0.leaderTimeout to 0
tick until 0.state is leader
tick 20
check 0.state is leader

cluster of 1
tick until 0.state is leader

cluster of 3
set 0.leaderTimeout to 0
tick until 0.state is leader
client foo bar baz
tick until stateMachine.data is baz

### Working out request flow for cluster reconfigurations
Client request to add a peer
Leader creates Cold,new, sends it through append entries, returns.
AppendEntries looks at stream as it goes by, sees new configuration, starts
  using it, commits entry like normally does.
Leader sees Cold,new committed, kicks off Cnew append entries, returns.
AppendEntries looks at stream as it goes by, sees new configuration, starts
  using it, commits entry like normally does

### Random questions
How do elections work with Cold,new?
How does an operator recover from something weird happening after the client
   request is sent off?

### Message Bus interface.

var messageId = self.messageBus.send(self.id, peer, message, onResponse);
self.messageBus.cancel(messageId);
